#!/usr/bin/env python3
"""
Script pour g√©n√©rer s√©quence d'√©motions pour GIF
Encha√Æne automatiquement : happy (2s) ‚Üí neutral (1s) ‚Üí curious (2s) ‚Üí excited (2s) ‚Üí calm (1s)
Total : 8 secondes, pr√™t pour enregistrement √©cran

Configuration :
- Cam√©ra orient√©e face au robot (azimuth configurable via --azimuth)
- Note : Le fond noir est une limitation de MuJoCo viewer (utiliser post-production pour fond pastel)
"""

import math
import sys
import time
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from bbia_sim.robot_factory import RobotFactory


def emotion_to_pose(
    emotion: str, intensity: float, step: int, total_steps: int
) -> float:
    """Convertit une √©motion en position d'articulation."""
    t = step / total_steps

    emotion_patterns = {
        "happy": (
            lambda t: 0.12
            * math.sin(2 * math.pi * 0.1 * t)
            * (1 + 0.5 * math.sin(4 * math.pi * t))
        ),
        "sad": (
            lambda t: -0.12 * math.sin(2 * math.pi * 0.3 * t)
            - 0.04 * math.sin(6 * math.pi * t)
        ),
        "angry": (
            lambda t: 0.18 * math.sin(2 * math.pi * 0.8 * t)
            + 0.04 * math.sin(8 * math.pi * t)
        ),
        "surprised": (
            lambda t: 0.15 * math.sin(2 * math.pi * 0.2 * t) * math.cos(3 * math.pi * t)
        ),
        "neutral": (
            lambda t: 0.08 * math.sin(2 * math.pi * 0.1 * t)
            + 0.03 * math.sin(6 * math.pi * t)
        ),
        "curious": (
            lambda t: 0.10
            * math.sin(2 * math.pi * 0.15 * t)
            * (1 + 0.3 * math.sin(3 * math.pi * t))
        ),
        "excited": (
            lambda t: 0.16
            * math.sin(2 * math.pi * 0.12 * t)
            * (1 + 0.8 * math.sin(5 * math.pi * t))
        ),
        "calm": lambda t: 0.06 * math.sin(2 * math.pi * 0.08 * t),
    }

    base_movement = emotion_patterns.get(emotion, emotion_patterns["neutral"])(t)
    return base_movement * intensity


def main():
    import argparse

    parser = argparse.ArgumentParser(description="G√©n√®re s√©quence d'√©motions pour GIF")
    parser.add_argument(
        "--azimuth",
        type=float,
        default=90.0,
        help="Angle azimuth cam√©ra (0=droite, 90=face, 180=gauche, 270=dos). Testez diff√©rentes valeurs!",
    )
    args = parser.parse_args()

    # S√©quence d'√©motions avec dur√©es
    sequence = [
        ("happy", 2.0, 0.8),
        ("neutral", 1.0, 0.5),
        ("curious", 2.0, 0.7),
        ("excited", 2.0, 0.9),
        ("calm", 1.0, 0.6),
    ]

    # Cr√©er le robot
    robot = RobotFactory.create_backend("mujoco")
    if not robot or not robot.connect():
        print("‚ùå Impossible de se connecter")
        return 1

    print("‚úÖ Robot connect√©")

    # Acc√©der au mod√®le et donn√©es MuJoCo directement
    if (
        not hasattr(robot, "model")
        or not hasattr(robot, "data")
        or robot.model is None
        or robot.data is None
    ):
        print("‚ùå Impossible d'acc√©der au mod√®le MuJoCo")
        return 1


    # Lancer viewer via le backend du robot
    print("‚úÖ Lancement viewer MuJoCo...")
    if not robot.launch_viewer(passive=True):
        print("‚ùå Impossible de lancer le viewer")
        return 1

    # Attendre que le viewer soit pr√™t
    time.sleep(0.5)

    # Acc√©der au viewer du backend
    if not hasattr(robot, "viewer") or robot.viewer is None:
        print("‚ùå Viewer non disponible")
        return 1

    viewer = robot.viewer

    # Configurer cam√©ra avec l'azimuth fourni en argument
    # 0¬∞ = c√¥t√© droit, 90¬∞ = face, 180¬∞ = c√¥t√© gauche, 270¬∞ = dos
    viewer.cam.azimuth = args.azimuth
    viewer.cam.elevation = -15.0  # L√©g√®rement au-dessus
    viewer.cam.distance = 1.5
    viewer.cam.lookat[:] = [0.0, 0.0, 0.3]

    # Synchroniser pour appliquer la configuration de la cam√©ra
    viewer.sync()
    time.sleep(0.2)  # Laisser le viewer se stabiliser

    print(f"‚úÖ Cam√©ra configur√©e (azimuth={args.azimuth}¬∞)")
    print("üí° Si le robot est encore de c√¥t√©, testez: --azimuth 90, 180, 270, ou -90")
    print(
        "‚ö†Ô∏è  Fond noir : limitation de MuJoCo viewer (utiliser post-production vid√©o pour fond pastel)"
    )

    print("\nüé¨ D√âBUT S√âQUENCE (8 secondes)")
    print("üìπ Pr√©parez votre enregistrement d'√©cran maintenant !\n")
    time.sleep(2)  # Temps pour d√©marrer l'enregistrement

    fps = 10
    total_duration = sum(duration for _, duration, _ in sequence)

    print(f"‚è±Ô∏è  Dur√©e totale : {total_duration}s\n")

    step_count = 0
    for emotion, duration, intensity in sequence:
        total_steps = int(duration * fps)
        print(f"üé≠ {emotion.upper()} ({duration}s, intensit√© {intensity})")

        for step in range(total_steps):
            angle = emotion_to_pose(emotion, intensity, step, total_steps)
            robot.set_joint_pos("yaw_body", angle)
            robot.step()

            # Maintenir la configuration de la cam√©ra √† chaque frame
            viewer.cam.azimuth = args.azimuth
            viewer.cam.elevation = -15.0
            viewer.cam.distance = 1.5
            viewer.cam.lookat[:] = [0.0, 0.0, 0.3]

            # Mettre √† jour la simulation
            viewer.sync()

            step_count += 1
            time.sleep(1.0 / fps)

    print(f"\n‚úÖ S√©quence termin√©e ({total_duration}s)")
    print("‚è∏Ô∏è  Arr√™tez votre enregistrement d'√©cran")
    print("üíæ Puis convertissez la vid√©o en GIF avec ffmpeg")
    print("\nüí° Pour le fond pastel : utilisez un filtre vid√©o (chromakey/fond color√©)")
    time.sleep(2)

    # Fermer proprement le viewer (sans force kill qui peut causer des probl√®mes)
    print("\nüîÑ Fermeture du viewer...")
    try:
        if hasattr(robot, "viewer") and robot.viewer is not None:
            # Fermeture simple et s√ªre
            try:
                if hasattr(robot.viewer, "close"):
                    robot.viewer.close()
                    time.sleep(0.3)  # Laisser le temps de fermer
                    print("‚úÖ Viewer ferm√©")
            except AttributeError:
                # Si le viewer n'a pas de m√©thode close, il se fermera avec le contexte
                pass
            except Exception as e:
                print(f"‚ö†Ô∏è  Viewer d√©j√† ferm√© ou erreur mineure: {e}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Note: {e}")

    # D√©connecter le robot
    try:
        robot.disconnect()
        print("‚úÖ Robot d√©connect√©")
    except Exception as e:
        print(f"‚ö†Ô∏è  Note lors de la d√©connexion: {e}")

    print("\nüí° Si une fen√™tre MuJoCo reste ouverte, fermez-la avec Cmd+Q")

    return 0


if __name__ == "__main__":
    exit(main())
