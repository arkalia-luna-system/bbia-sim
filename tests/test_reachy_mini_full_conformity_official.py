#!/usr/bin/env python3
"""
üß™ TEST DE CONFORMIT√â COMPL√àTE REACHY-MINI VS SDK OFFICIEL
V√©rifie que notre impl√©mentation est 100% conforme au SDK officiel Reachy Mini
Bas√© sur les sp√©cifications officielles de Pollen Robotics (Octobre 2025)
"""

import inspect
import sys
import time
from pathlib import Path

import pytest

# Ajouter le chemin src au PYTHONPATH
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from bbia_sim.backends.reachy_mini_backend import ReachyMiniBackend
from bbia_sim.robot_api import RobotAPI

# Tentative d'import du SDK officiel
try:
    from reachy_mini import ReachyMini
    from reachy_mini.utils import create_head_pose

    SDK_AVAILABLE = True
except ImportError:
    SDK_AVAILABLE = False
    ReachyMini = None
    create_head_pose = None


class TestReachyMiniFullConformity:
    """Tests de conformit√© compl√®te avec le SDK Reachy Mini officiel."""

    # M√âTHODES OFFICIELLES DU SDK REACHY-MINI (d'apr√®s documentation GitHub)
    EXPECTED_SDK_METHODS = {
        "wake_up": {"args": [], "return": None},
        "goto_sleep": {"args": [], "return": None},
        "get_current_joint_positions": {"args": [], "return": tuple},
        "set_target_head_pose": {"args": ["pose"], "return": None},
        "set_target_body_yaw": {"args": ["body_yaw"], "return": None},
        "set_target_antenna_joint_positions": {"args": ["antennas"], "return": None},
        "get_current_head_pose": {"args": [], "return": "ndarray"},
        "get_present_antenna_joint_positions": {"args": [], "return": list},
        "look_at_world": {
            "args": ["x", "y", "z", "duration", "perform_movement"],
            "return": "ndarray",
        },
        "look_at_image": {
            "args": ["u", "v", "duration", "perform_movement"],
            "return": "ndarray",
        },
        "goto_target": {
            "args": ["head", "antennas", "duration", "method", "body_yaw"],
            "return": None,
        },
        "set_target": {"args": ["head", "antennas", "body_yaw"], "return": None},
        "enable_motors": {"args": [], "return": None},
        "disable_motors": {"args": [], "return": None},
        "enable_gravity_compensation": {"args": [], "return": None},
        "disable_gravity_compensation": {"args": [], "return": None},
        "set_automatic_body_yaw": {"args": ["body_yaw"], "return": None},
    }

    # JOINTS OFFICIELS REACHY-MINI (d'apr√®s mod√®le physique)
    EXPECTED_JOINTS = {
        "stewart_1",
        "stewart_2",
        "stewart_3",
        "stewart_4",
        "stewart_5",
        "stewart_6",
        "left_antenna",
        "right_antenna",
        "yaw_body",
    }

    # √âMOTIONS OFFICIELLES REACHY-MINI
    EXPECTED_EMOTIONS = {"happy", "sad", "neutral", "excited", "curious", "calm"}

    # COMPORTEMENTS OFFICIELS
    EXPECTED_BEHAVIORS = {"wake_up", "goto_sleep", "nod"}

    def setup_method(self):
        """Configuration avant chaque test."""
        self.backend: ReachyMiniBackend = ReachyMiniBackend()
        self.backend.connect()

    def teardown_method(self):
        """Nettoyage apr√®s chaque test."""
        if self.backend:
            self.backend.disconnect()

    def test_01_sdk_availability(self):
        """Test 1: V√©rifier que le SDK officiel est disponible."""
        print("\nüß™ TEST 1: Disponibilit√© SDK")
        print("=" * 60)

        if SDK_AVAILABLE:
            print("‚úÖ SDK officiel reachy_mini disponible")
            print("‚úÖ Classe ReachyMini import√©e")
            print("‚úÖ Utilitaires SDK import√©s")
            assert True
        else:
            print("‚ö†Ô∏è  SDK officiel non install√©")
            print("üí° Installez avec: pip install reachy-mini")
            # Ne pas √©chouer - tester quand m√™me en mode simulation
            pytest.skip("SDK officiel non disponible")

    def test_02_methods_existence(self):
        """Test 2: V√©rifier que toutes les m√©thodes SDK existent."""
        print("\nüß™ TEST 2: Existence des m√©thodes")
        print("=" * 60)

        missing_methods = []
        for method_name in self.EXPECTED_SDK_METHODS.keys():
            if not hasattr(self.backend, method_name):
                missing_methods.append(method_name)
                print(f"‚ùå M√©thode manquante: {method_name}")
            else:
                print(f"‚úÖ M√©thode disponible: {method_name}")

        assert (
            len(missing_methods) == 0
        ), f"M√©thodes manquantes: {', '.join(missing_methods)}"

    def test_03_methods_signatures(self):
        """Test 3: V√©rifier les signatures des m√©thodes."""
        print("\nüß™ TEST 3: Signatures des m√©thodes")
        print("=" * 60)

        signature_errors = []
        for method_name, expected in self.EXPECTED_SDK_METHODS.items():
            if not hasattr(self.backend, method_name):
                continue

            method = getattr(self.backend, method_name)
            sig = inspect.signature(method)
            actual_args = list(sig.parameters.keys())
            actual_args = [a for a in actual_args if a != "self"]  # Enlever self

            expected_args = expected["args"]

            # V√©rifier les arguments (ordre flexible)
            missing_args = [arg for arg in expected_args if arg not in actual_args]
            if missing_args:
                signature_errors.append(
                    f"{method_name}: arguments manquants {missing_args}"
                )
                print(f"‚ùå {method_name}: {missing_args}")
            else:
                print(f"‚úÖ {method_name}: signature correcte")

        assert (
            len(signature_errors) == 0
        ), f"Erreurs de signatures: {', '.join(signature_errors)}"

    def test_04_joints_official_mapping(self):
        """Test 4: V√©rifier le mapping des joints officiels."""
        print("\nüß™ TEST 4: Mapping des joints officiels")
        print("=" * 60)

        available_joints = set(self.backend.get_available_joints())

        # V√©rifier que tous les joints officiels sont pr√©sents
        missing_joints = self.EXPECTED_JOINTS - available_joints
        extra_joints = available_joints - self.EXPECTED_JOINTS

        if missing_joints:
            print(f"‚ùå Joints manquants: {missing_joints}")
        if extra_joints:
            print(f"‚ö†Ô∏è  Joints suppl√©mentaires: {extra_joints}")

        for joint in available_joints:
            if joint in self.EXPECTED_JOINTS:
                print(f"‚úÖ Joint officiel: {joint}")
            else:
                print(f"‚ÑπÔ∏è  Joint suppl√©mentaire: {joint}")

        # Les joints officiels doivent tous √™tre pr√©sents
        assert (
            not missing_joints
        ), f"Joints officiels manquants: {', '.join(missing_joints)}"

    def test_05_emotions_official(self):
        """Test 5: V√©rifier les √©motions officielles."""
        print("\nüß™ TEST 5: √âmotions officielles")
        print("=" * 60)

        emotion_errors = []
        for emotion in self.EXPECTED_EMOTIONS:
            result = self.backend.set_emotion(emotion, 0.5)
            if result:
                print(f"‚úÖ √âmotion valide: {emotion}")
            else:
                emotion_errors.append(emotion)
                print(f"‚ùå √âmotion invalide: {emotion}")

        # Tester qu'une √©motion invalide est rejet√©e
        invalid_result = self.backend.set_emotion("invalid_emotion", 0.5)
        if not invalid_result:
            print("‚úÖ √âmotions invalides correctement rejet√©es")
        else:
            print("‚ùå Les √©motions invalides ne sont pas rejet√©es")

        assert (
            len(emotion_errors) == 0
        ), f"√âmotions invalides: {', '.join(emotion_errors)}"
        assert not invalid_result, "Les √©motions invalides devraient √™tre rejet√©es"

    def test_06_behaviors_official(self):
        """Test 6: V√©rifier les comportements officiels."""
        print("\nüß™ TEST 6: Comportements officiels")
        print("=" * 60)

        behavior_errors = []
        for behavior in self.EXPECTED_BEHAVIORS:
            result = self.backend.run_behavior(behavior, 1.0)
            if result:
                print(f"‚úÖ Comportement valide: {behavior}")
            else:
                behavior_errors.append(behavior)
                print(f"‚ùå Comportement invalide: {behavior}")

        assert (
            len(behavior_errors) == 0
        ), f"Comportements invalides: {', '.join(behavior_errors)}"

    def test_07_joint_limits_official(self):
        """Test 7: V√©rifier les limites des joints officiels."""
        print("\nüß™ TEST 7: Limites des joints")
        print("=" * 60)

        # V√©rifier que les limites sont d√©finies pour tous les joints
        limit_errors = []
        for joint in self.EXPECTED_JOINTS:
            if joint in self.backend.joint_limits:
                limits = self.backend.joint_limits[joint]
                print(f"‚úÖ Joint {joint}: limites {limits}")
            else:
                limit_errors.append(joint)
                print(f"‚ùå Joint {joint}: pas de limites d√©finies")

        assert len(limit_errors) == 0, f"Joints sans limites: {', '.join(limit_errors)}"

    def test_08_safety_forbidden_joints(self):
        """Test 8: V√©rifier que les joints fragiles sont prot√©g√©s."""
        print("\nüß™ TEST 8: Protection des joints fragiles")
        print("=" * 60)

        # V√©rifier que les antennes sont prot√©g√©es
        forbidden = self.backend.forbidden_joints
        assert "left_antenna" in forbidden, "left_antenna devrait √™tre prot√©g√©"
        assert "right_antenna" in forbidden, "right_antenna devrait √™tre prot√©g√©"

        print("‚úÖ left_antenna prot√©g√©")
        print("‚úÖ right_antenna prot√©g√©")

        # V√©rifier que les mouvements sur joints interdits sont bloqu√©s
        for joint in ["left_antenna", "right_antenna"]:
            result = self.backend.set_joint_pos(joint, 0.1)
            assert not result, f"Les mouvements sur {joint} devraient √™tre bloqu√©s"

        print("‚úÖ Mouvements sur joints interdits bloqu√©s")

    def test_09_safe_amplitude_limit(self):
        """Test 9: V√©rifier la limite d'amplitude s√©curis√©e."""
        print("\nüß™ TEST 9: Limite d'amplitude")
        print("=" * 60)

        # La limite officielle est 0.3 rad
        expected_limit = 0.3
        actual_limit = self.backend.safe_amplitude_limit

        print(f"üìä Limite attendue: {expected_limit} rad")
        print(f"üìä Limite actuelle: {actual_limit} rad")

        assert (
            actual_limit == expected_limit
        ), f"Limite incorrecte: {actual_limit} vs {expected_limit}"
        print("‚úÖ Limite d'amplitude correcte")

        # V√©rifier que les amplitudes excessives sont clamp√©es
        extreme_value = 2.0  # > 0.3
        result = self.backend.set_joint_pos("stewart_1", extreme_value)
        if result:
            print("‚úÖ Amplitude excessive clamp√©e")
        else:
            print("‚ö†Ô∏è  Amplitude excessive rejet√©e (acceptable)")

    def test_10_telemetry_official(self):
        """Test 10: V√©rifier la t√©l√©m√©trie officielle."""
        print("\nüß™ TEST 10: T√©l√©m√©trie")
        print("=" * 60)

        required_fields = {
            "step_count",
            "elapsed_time",
            "steps_per_second",
            "current_emotion",
            "emotion_intensity",
            "is_connected",
        }

        telemetry = self.backend.get_telemetry()

        missing_fields = []
        for field in required_fields:
            if field not in telemetry:
                missing_fields.append(field)
                print(f"‚ùå Champ manquant: {field}")
            else:
                print(f"‚úÖ Champ pr√©sent: {field}")

        assert (
            len(missing_fields) == 0
        ), f"Champs t√©l√©m√©trie manquants: {', '.join(missing_fields)}"

    def test_11_performance_official(self):
        """Test 11: V√©rifier les performances."""
        print("\nüß™ TEST 11: Performances")
        print("=" * 60)

        # Mesurer la latence des op√©rations critiques
        test_joint = "stewart_1"
        iterations = 100

        start_time = time.time()
        for _ in range(iterations):
            self.backend.set_joint_pos(test_joint, 0.1)
            self.backend.get_joint_pos(test_joint)
        end_time = time.time()

        avg_latency_ms = (end_time - start_time) / iterations * 1000
        print(f"üìä Latence moyenne: {avg_latency_ms:.2f} ms")

        # En simulation, la latence doit √™tre < 1ms
        assert avg_latency_ms < 10, f"Latence trop √©lev√©e: {avg_latency_ms:.2f} ms"

    def test_12_simulation_mode(self):
        """Test 12: V√©rifier le mode simulation."""
        print("\nüß™ TEST 12: Mode simulation")
        print("=" * 60)

        # Toutes les op√©rations doivent fonctionner en simulation
        print("üß™ Test des op√©rations en mode simulation...")

        # Test mouvements
        result = self.backend.set_joint_pos("stewart_1", 0.1)
        assert result, "set_joint_pos devrait fonctionner en simulation"
        print("‚úÖ set_joint_pos fonctionne en simulation")

        # Test √©motions
        result = self.backend.set_emotion("happy", 0.8)
        assert result, "set_emotion devrait fonctionner en simulation"
        print("‚úÖ set_emotion fonctionne en simulation")

        # Test look_at
        result = self.backend.look_at(0.1, 0.2, 0.3)
        assert result, "look_at devrait fonctionner en simulation"
        print("‚úÖ look_at fonctionne en simulation")

        # Test comportements
        result = self.backend.run_behavior("wake_up", 1.0)
        assert result, "run_behavior devrait fonctionner en simulation"
        print("‚úÖ run_behavior fonctionne en simulation")

    def test_13_api_consistency(self):
        """Test 13: V√©rifier la coh√©rence de l'API."""
        print("\nüß™ TEST 13: Coh√©rence API")
        print("=" * 60)

        # V√©rifier que RobotAPI est respect√©e
        assert isinstance(self.backend, RobotAPI), "Le backend doit h√©riter de RobotAPI"
        print("‚úÖ H√©ritage RobotAPI correct")

        # V√©rifier que toutes les m√©thodes abstraites sont impl√©ment√©es
        abstract_methods = ["connect", "disconnect", "get_available_joints"]
        for method_name in abstract_methods:
            assert hasattr(
                self.backend, method_name
            ), f"M√©thode {method_name} manquante"
            print(f"‚úÖ M√©thode abstraite impl√©ment√©e: {method_name}")

    def test_14_sdk_official_comparison(self):
        """Test 14: Comparer avec le SDK officiel (si disponible)."""
        print("\nüß™ TEST 14: Comparaison avec SDK officiel")
        print("=" * 60)

        if not SDK_AVAILABLE:
            print("‚ö†Ô∏è  SDK officiel non disponible, test ignor√©")
            pytest.skip("SDK officiel non disponible")

        # Si le SDK est disponible, on peut faire des comparaisons
        print("‚úÖ SDK officiel disponible")
        print("‚úÖ Comparaison avec SDK officiel possible")

        # V√©rifier que les m√©thodes de notre backend correspondent au SDK
        sdk_compatible = True
        for method_name in self.EXPECTED_SDK_METHODS.keys():
            # V√©rifier que la m√©thode existe dans notre backend
            if not hasattr(self.backend, method_name):
                print(f"‚ùå M√©thode {method_name} manquante")
                sdk_compatible = False

        if sdk_compatible:
            print("‚úÖ Toutes les m√©thodes SDK sont compatibles")

    def test_15_return_types(self):
        """Test 15: V√©rifier les types de retour."""
        print("\nüß™ TEST 15: Types de retour")
        print("=" * 60)

        # Test get_joint_pos retourne float
        result = self.backend.get_joint_pos("stewart_1")
        assert isinstance(
            result, (float, type(None))
        ), "get_joint_pos doit retourner float ou None"
        print("‚úÖ get_joint_pos retourne float")

        # Test set_joint_pos retourne bool
        result = self.backend.set_joint_pos("stewart_1", 0.1)
        assert isinstance(result, bool), "set_joint_pos doit retourner bool"
        print("‚úÖ set_joint_pos retourne bool")

        # Test set_emotion retourne bool
        result = self.backend.set_emotion("happy", 0.5)
        assert isinstance(result, bool), "set_emotion doit retourner bool"
        print("‚úÖ set_emotion retourne bool")

        # Test get_telemetry retourne dict
        result = self.backend.get_telemetry()
        assert isinstance(result, dict), "get_telemetry doit retourner dict"
        print("‚úÖ get_telemetry retourne dict")

        # Test get_available_joints retourne list
        result = self.backend.get_available_joints()
        assert isinstance(result, list), "get_available_joints doit retourner list"
        print("‚úÖ get_available_joints retourne list")

    def test_16_joint_names_official(self):
        """Test 16: V√©rifier que les noms de joints sont officiels."""
        print("\nüß™ TEST 16: Noms de joints officiels")
        print("=" * 60)

        # Les noms de joints doivent correspondre exactement au SDK officiel
        # stewart_1 √† stewart_6, left_antenna, right_antenna, yaw_body

        available_joints = set(self.backend.get_available_joints())

        # V√©rifier les noms exacts
        correct_names = True
        for joint in available_joints:
            if not any(
                [
                    joint.startswith("stewart_")
                    and joint.replace("stewart_", "").isdigit(),
                    joint in ["left_antenna", "right_antenna", "yaw_body"],
                ]
            ):
                print(f"‚ùå Nom de joint non standard: {joint}")
                correct_names = False
            else:
                print(f"‚úÖ Nom de joint standard: {joint}")

        assert correct_names, "Tous les noms de joints doivent √™tre standard"

    def test_17_full_integration(self):
        """Test 17: Test d'int√©gration complet."""
        print("\nüß™ TEST 17: Int√©gration compl√®te")
        print("=" * 60)

        # Simuler une s√©quence compl√®te de mouvement
        print("üé¨ S√©quence compl√®te de mouvement...")

        # 1. Wake up
        result = self.backend.run_behavior("wake_up", 1.0)
        assert result, "wake_up doit r√©ussir"
        print("‚úÖ wake_up r√©ussi")

        # 2. √âmotion
        result = self.backend.set_emotion("excited", 0.8)
        assert result, "set_emotion doit r√©ussir"
        print("‚úÖ set_emotion r√©ussi")

        # 3. Mouvements t√™te
        result = self.backend.set_joint_pos("stewart_1", 0.1)
        assert result, "set_joint_pos doit r√©ussir"
        print("‚úÖ set_joint_pos r√©ussi")

        # 4. Look at
        result = self.backend.look_at(0.1, 0.2, 0.3)
        assert result, "look_at doit r√©ussir"
        print("‚úÖ look_at r√©ussi")

        # 5. T√©l√©m√©trie
        telemetry = self.backend.get_telemetry()
        assert isinstance(telemetry, dict), "get_telemetry doit retourner dict"
        print("‚úÖ t√©l√©m√©trie r√©cup√©r√©e")

        print("üéâ Int√©gration compl√®te r√©ussie!")

    def test_18_documentation_compliance(self):
        """Test 18: V√©rifier que toutes les m√©thodes ont une docstring."""
        print("\nüß™ TEST 18: Documentation")
        print("=" * 60)

        methods_without_doc = []
        for method_name in self.EXPECTED_SDK_METHODS.keys():
            if not hasattr(self.backend, method_name):
                continue

            method = getattr(self.backend, method_name)
            if not method.__doc__:
                methods_without_doc.append(method_name)
                print(f"‚ùå Pas de docstring: {method_name}")
            else:
                print(f"‚úÖ Docstring pr√©sente: {method_name}")

        # Ce n'est pas critique, juste informatif
        if methods_without_doc:
            print(f"‚ö†Ô∏è  {len(methods_without_doc)} m√©thodes sans docstring")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
