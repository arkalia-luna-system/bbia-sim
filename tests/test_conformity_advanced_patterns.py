#!/usr/bin/env python3
"""
üß™ TESTS AVANC√âS - D√âTECTION PATTERNS INEFFICACES ET NON CONFORMES
D√©tecte des probl√®mes subtils que seuls les experts en robotique IA √©motionnelle verraient:
- Usage inefficace (set_joint_pos r√©p√©t√©s au lieu de goto_target)
- Interpolation non adapt√©e aux √©motions
- Dur√©es non adaptatives
- Modules ne passant pas robot_api pour robot.media
"""

import re
import sys
from pathlib import Path

import pytest

# Ajouter le chemin src au PYTHONPATH
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))


class TestConformityAdvancedPatterns:
    """Tests pour d√©tecter patterns inefficaces et non conformes."""

    def test_detect_inefficient_joint_control_patterns(self):
        """Test Expert 1: D√©tecter usage inefficace (set_joint_pos r√©p√©t√©s au lieu de goto_target combin√©)."""
        print("\nüß™ TEST EXPERT 1: D√©tection patterns inefficaces")
        print("=" * 60)

        src_dir = Path(__file__).parent.parent / "src" / "bbia_sim"
        if not src_dir.exists():
            pytest.skip("Dossier src/bbia_sim introuvable")

        # Chercher fichiers avec set_joint_pos r√©p√©t√©s pour t√™te+corps
        inefficient_patterns = []

        for py_file in src_dir.rglob("*.py"):
            # Ignorer backends (peuvent utiliser m√©thodes bas niveau)
            if "backends" in str(py_file) or "__pycache__" in str(py_file):
                continue

            content = py_file.read_text(encoding="utf-8")
            lines = content.split("\n")

            # Chercher s√©quences de set_joint_pos multiples (potentiellement inefficace)
            for i, line in enumerate(lines):
                stripped = line.strip()
                # Ignorer commentaires
                if stripped.startswith("#") or stripped.startswith('"""'):
                    continue

                # D√©tecter set_joint_pos pour t√™te suivi de set_joint_pos pour corps
                # (devrait √™tre goto_target combin√©)
                if "set_joint_pos" in line and (
                    "head" in line.lower() or "stewart" in line.lower()
                ):
                    # Chercher set_joint_pos suivant pour yaw_body dans les 5 prochaines lignes
                    for j in range(i + 1, min(i + 6, len(lines))):
                        if "set_joint_pos" in lines[j] and "yaw_body" in lines[j]:
                            # V√©rifier si goto_target n'est pas utilis√© √† la place
                            context = "\n".join(
                                lines[max(0, i - 3) : min(len(lines), j + 3)]
                            )
                            if "goto_target" not in context:
                                inefficient_patterns.append((py_file, i + 1, j + 1))

        if inefficient_patterns:
            print(f"‚ö†Ô∏è  Patterns inefficaces d√©tect√©s: {len(inefficient_patterns)}")
            for f, line1, line2 in inefficient_patterns[:5]:  # Limiter affichage
                print(
                    f"   {f.name}:{line1}-{line2} (set_joint_pos s√©par√©s au lieu de goto_target combin√©)"
                )
        else:
            print("‚úÖ Aucun pattern inefficace d√©tect√©")

        # Ne pas bloquer mais alerter (peut √™tre acceptable dans certains cas)
        if len(inefficient_patterns) > 3:
            print(
                "\nüí° Recommandation: Consid√©rer utiliser goto_target combin√© pour meilleure performance"
            )

    def test_interpolation_adaptive_to_emotions(self):
        """Test Expert 2: V√©rifier que l'interpolation s'adapte aux √©motions."""
        print("\nüß™ TEST EXPERT 2: Interpolation adaptative aux √©motions")
        print("=" * 60)

        integration_file = (
            Path(__file__).parent.parent / "src" / "bbia_sim" / "bbia_integration.py"
        )
        if not integration_file.exists():
            pytest.skip("Fichier bbia_integration.py introuvable")

        content = integration_file.read_text(encoding="utf-8")

        # V√©rifier pr√©sence mapping √©motion ‚Üí interpolation
        has_emotion_interpolation_map = "emotion_interpolation_map" in content
        has_cartoon = '"cartoon"' in content or "'cartoon'" in content
        has_ease_in_out = '"ease_in_out"' in content or "'ease_in_out'" in content
        uses_interpolation_in_goto = (
            "method=interpolation_method" in content
            or "method=emotion_interpolation" in content
        )

        assert has_emotion_interpolation_map, (
            "EXPERT: bbia_integration doit avoir emotion_interpolation_map. "
            "Sans mapping = interpolation non adapt√©e = mouvements moins expressifs."
        )
        print("‚úÖ emotion_interpolation_map pr√©sent")

        assert has_cartoon, (
            "EXPERT: Mapping doit inclure 'cartoon' pour √©motions expressives. "
            "Sans cartoon = mouvements trop uniformes pour happy/excited."
        )
        print("‚úÖ 'cartoon' utilis√© pour √©motions expressives")

        assert has_ease_in_out, (
            "EXPERT: Mapping doit inclure 'ease_in_out' pour √©motions douces. "
            "Sans ease_in_out = mouvements trop brusques pour calm/sad."
        )
        print("‚úÖ 'ease_in_out' utilis√© pour √©motions douces")

        assert uses_interpolation_in_goto, (
            "EXPERT: L'interpolation doit √™tre utilis√©e dans goto_target. "
            "Mapping sans utilisation = code mort."
        )
        print("‚úÖ Interpolation utilis√©e dans goto_target")

    def test_duration_adaptive_to_intensity(self):
        """Test Expert 3: V√©rifier que la dur√©e s'adapte √† l'intensit√© √©motionnelle."""
        print("\nüß™ TEST EXPERT 3: Dur√©e adaptative selon intensit√©")
        print("=" * 60)

        integration_file = (
            Path(__file__).parent.parent / "src" / "bbia_sim" / "bbia_integration.py"
        )
        if not integration_file.exists():
            pytest.skip("Fichier bbia_integration.py introuvable")

        content = integration_file.read_text(encoding="utf-8")

        # V√©rifier pr√©sence duration adaptative
        has_adaptive_duration = (
            "transition_duration" in content
            or "duration.*intensity" in content
            or "intensity.*duration" in content
        )

        # V√©rifier formule adaptative (0.5 + intensity * quelque chose)
        has_formula = re.search(r"duration.*=.*0\.\d+.*[\+\-].*intensity", content)

        assert has_adaptive_duration or has_formula, (
            "EXPERT: La dur√©e doit s'adapter √† l'intensit√© √©motionnelle (0.5-1.0s). "
            "Dur√©e fixe = mouvements moins expressifs pour intensit√©s √©lev√©es."
        )
        print("‚úÖ Dur√©e adaptative selon intensit√© d√©tect√©e")

    def test_modules_pass_robot_api_for_media(self):
        """Test Expert 4: V√©rifier que les modules re√ßoivent robot_api pour utiliser robot.media."""
        print("\nüß™ TEST EXPERT 4: Modules re√ßoivent robot_api pour robot.media")
        print("=" * 60)

        # V√©rifier bbia_vision.py
        vision_file = (
            Path(__file__).parent.parent / "src" / "bbia_sim" / "bbia_vision.py"
        )
        if vision_file.exists():
            content = vision_file.read_text(encoding="utf-8")
            has_robot_api_param = (
                "robot_api"
                in re.search(r"def __init__.*?:", content, re.DOTALL).group(0)
                if re.search(r"def __init__.*?:", content, re.DOTALL)
                else False
            )
            has_media_check = (
                "robot.media" in content or "_camera_sdk_available" in content
            )

            assert has_robot_api_param and has_media_check, (
                "EXPERT: BBIAVision doit accepter robot_api et v√©rifier robot.media.camera. "
                "Sans = ne peut pas utiliser cam√©ra SDK (perte performance/qualit√©)."
            )
            print("‚úÖ BBIAVision accepte robot_api et v√©rifie robot.media")

        # V√©rifier bbia_integration.py passe robot_api aux modules
        integration_file = (
            Path(__file__).parent.parent / "src" / "bbia_sim" / "bbia_integration.py"
        )
        if integration_file.exists():
            content = integration_file.read_text(encoding="utf-8")
            passes_to_vision = "BBIAVision(robot_api=" in content

            assert passes_to_vision, (
                "EXPERT: BBIAIntegration doit passer robot_api √† BBIAVision. "
                "Sans = modules ne peuvent pas utiliser robot.media."
            )
            print("‚úÖ BBIAIntegration passe robot_api √† BBIAVision")

    def test_no_hardcoded_stewart_control_in_main_modules(self):
        """Test Expert 5: Aucun contr√¥le stewart hardcod√© dans modules principaux."""
        print("\nüß™ TEST EXPERT 5: Absence contr√¥le stewart hardcod√©")
        print("=" * 60)

        src_dir = Path(__file__).parent.parent / "src" / "bbia_sim"
        if not src_dir.exists():
            pytest.skip("Dossier src/bbia_sim introuvable")

        # Exclure backends (peuvent avoir code SDK bas niveau)
        exclude_patterns = ["backends", "__pycache__", "__init__"]

        # Chercher set_joint_pos avec "stewart" hardcod√© (hors commentaires)
        hardcoded_stewart = []

        for py_file in src_dir.rglob("*.py"):
            if any(pattern in str(py_file) for pattern in exclude_patterns):
                continue

            content = py_file.read_text(encoding="utf-8")
            lines = content.split("\n")

            for i, line in enumerate(lines, 1):
                stripped = line.strip()
                # Ignorer commentaires et docstrings
                if (
                    stripped.startswith("#")
                    or stripped.startswith('"""')
                    or stripped.startswith("'''")
                ):
                    continue

                # Chercher set_joint_pos avec "stewart_" en dur
                if re.search(r'set_joint_pos\(["\']stewart_\d', line):
                    hardcoded_stewart.append((py_file, i, line.strip()))

        if hardcoded_stewart:
            print(f"‚ö†Ô∏è  Contr√¥le stewart hardcod√© d√©tect√©: {len(hardcoded_stewart)}")
            for f, line_num, line_content in hardcoded_stewart[:3]:
                print(f"   {f.name}:{line_num}: {line_content[:60]}...")
        else:
            print("‚úÖ Aucun contr√¥le stewart hardcod√© dans modules principaux")

        assert len(hardcoded_stewart) == 0, (
            f"EXPERT: {len(hardcoded_stewart)} usage(s) hardcod√©(s) de stewart dans modules principaux. "
            f"Modules principaux doivent utiliser goto_target avec IK (conforme SDK)."
        )

    def test_fallback_graceful_for_all_features(self):
        """Test Expert 6: Tous les features avanc√©s ont des fallbacks gracieux."""
        print("\nüß™ TEST EXPERT 6: Fallbacks gracieux pour features avanc√©s")
        print("=" * 60)

        src_dir = Path(__file__).parent.parent / "src" / "bbia_sim"
        if not src_dir.exists():
            pytest.skip("Dossier src/bbia_sim introuvable")

        # Features avanc√©s n√©cessitant fallbacks
        advanced_features = {
            "robot.media": ["_camera_sdk_available", "microphone_sdk", "speaker"],
            "goto_target": ["hasattr(robot_api, 'goto_target')"],
            "async_play_move": ["hasattr(robot_api, 'async_play_move')"],
            "recording": ["start_recording", "stop_recording"],
        }

        missing_fallbacks = []

        for py_file in src_dir.rglob("*.py"):
            if "__pycache__" in str(py_file):
                continue

            content = py_file.read_text(encoding="utf-8")

            for feature, indicators in advanced_features.items():
                # Chercher usage du feature
                if any(indicator in content for indicator in indicators):
                    # V√©rifier pr√©sence fallback (try/except ou hasattr check)
                    has_try_except = "try:" in content and "except" in content
                    has_hasattr_check = "hasattr" in content
                    has_none_check = "is None" in content or "== None" in content

                    if not (has_try_except or has_hasattr_check or has_none_check):
                        missing_fallbacks.append((py_file, feature))

        if missing_fallbacks:
            print(f"‚ö†Ô∏è  Features sans fallback d√©tect√©s: {len(missing_fallbacks)}")
            for f, feature in missing_fallbacks[:5]:
                print(f"   {f.name}: {feature}")
        else:
            print("‚úÖ Tous les features avanc√©s ont des fallbacks gracieux")

        # Ne pas bloquer mais alerter
        if len(missing_fallbacks) > 5:
            print(
                "\nüí° Recommandation: Ajouter fallbacks pour √©viter r√©gression si SDK non disponible"
            )


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
