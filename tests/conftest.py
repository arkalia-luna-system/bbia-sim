#!/usr/bin/env python3
"""
Configuration globale pytest avec syst√®me de verrouillage pour √©viter
l'ex√©cution simultan√©e de plusieurs instances de tests.
"""

import atexit
import fcntl
import os
import sys
import time
from pathlib import Path

import pytest

# Chemin vers le fichier de lock
LOCK_FILE = Path(__file__).parent.parent / ".pytest.lock"
LOCK_TIMEOUT = 300  # 5 minutes max pour un run de tests


def acquire_lock() -> bool:
    """
    Acquiert un verrou exclusif pour emp√™cher l'ex√©cution simultan√©e.

    Returns:
        True si le lock est acquis, False sinon.
    """
    if not LOCK_FILE.parent.exists():
        LOCK_FILE.parent.mkdir(parents=True, exist_ok=True)

    try:
        # Ouvrir le fichier en mode append
        lock_fd = os.open(str(LOCK_FILE), os.O_CREAT | os.O_WRONLY | os.O_TRUNC)

        # Tenter d'acqu√©rir le lock exclusif (non-bloquant)
        try:
            fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)

            # √âcrire le PID et timestamp
            pid = os.getpid()
            timestamp = time.time()
            os.write(lock_fd, f"{pid}:{timestamp}\n".encode())
            os.fsync(lock_fd)

            # Enregistrer la lib√©ration du lock √† la fin
            atexit.register(release_lock, lock_fd)

            return True
        except BlockingIOError:
            # Lock d√©j√† acquis par un autre processus
            os.close(lock_fd)

            # Lire qui a le lock
            try:
                with open(LOCK_FILE) as f:
                    lock_info = f.read().strip()
                    pid, timestamp_str = lock_info.split(":")
                    lock_timestamp = float(timestamp_str)

                    # V√©rifier si le processus existe encore
                    try:
                        os.kill(int(pid), 0)  # V√©rifier si processus existe
                        elapsed = time.time() - lock_timestamp

                        if elapsed > LOCK_TIMEOUT:
                            # Lock expir√© (processus probablement mort)
                            print(
                                f"‚ö†Ô∏è  Lock expir√© (>{LOCK_TIMEOUT}s). "
                                f"Processus {pid} pourrait √™tre mort. "
                                f"Suppression du lock..."
                            )
                            os.remove(LOCK_FILE)
                            # R√©essayer une fois
                            return acquire_lock()
                        else:
                            print(
                                f"‚ùå Tests d√©j√† en cours d'ex√©cution !\n"
                                f"   Processus PID: {pid}\n"
                                f"   Lock acquis il y a: {elapsed:.1f}s\n"
                                f"   Fichier lock: {LOCK_FILE}\n\n"
                                f"üí° Solutions:\n"
                                f"   1. Attendre la fin de l'autre processus\n"
                                f"   2. V√©rifier: ps aux | grep {pid}\n"
                                f"   3. Si processus mort: rm {LOCK_FILE}\n"
                                f"   4. Timeout automatique apr√®s {LOCK_TIMEOUT}s\n"
                            )
                            return False
                    except ProcessLookupError:
                        # Processus n'existe plus, lock orphelin
                        print(
                            f"‚ö†Ô∏è  Lock orphelin d√©tect√© (processus {pid} n'existe plus). "
                            f"Suppression..."
                        )
                        os.remove(LOCK_FILE)
                        # R√©essayer une fois
                        return acquire_lock()
            except Exception as e:
                print(f"‚ö†Ô∏è  Erreur lecture lock: {e}. Suppression du lock...")
                try:
                    os.remove(LOCK_FILE)
                except Exception:
                    pass
                return False

    except Exception as e:
        print(f"‚ö†Ô∏è  Erreur cr√©ation lock: {e}")
        return False


def release_lock(lock_fd: int) -> None:
    """Lib√®re le lock √† la fin des tests."""
    try:
        fcntl.flock(lock_fd, fcntl.LOCK_UN)
        os.close(lock_fd)
        try:
            os.remove(LOCK_FILE)
        except Exception:
            pass
    except Exception:
        pass


@pytest.hookimpl(tryfirst=True)
def pytest_configure(config: pytest.Config) -> None:
    """
    Hook pytest qui s'ex√©cute au d√©marrage.
    V√©rifie le lock avant de lancer les tests.
    """
    # Acqu√©rir le lock uniquement dans pytest
    # (ce hook ne s'ex√©cute que si on est vraiment dans pytest)
    if not acquire_lock():
        print("\n‚ùå Impossible d'acqu√©rir le verrou d'ex√©cution.")
        print("   Un autre processus ex√©cute d√©j√† les tests.\n")
        sys.exit(1)

    print("‚úÖ Verrou d'ex√©cution acquis. Tests s√©curis√©s.\n")


@pytest.hookimpl(trylast=True)
def pytest_unconfigure(config: pytest.Config) -> None:
    """Hook pytest qui s'ex√©cute √† la fin des tests."""
    # Le lock sera lib√©r√© par atexit, mais on peut aussi le faire ici
    try:
        if LOCK_FILE.exists():
            os.remove(LOCK_FILE)
    except Exception:
        pass
